import { OntologyTree, OntologyNode } from '../../shared/types';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport class OntologyService {\n  /**\n   * Create a new ontology node\n   */\n  static createNode(\n    label: string, \n    parentId?: string, \n    attributes?: { [key: string]: string }\n  ): OntologyNode {\n    const id = label.toLowerCase().replace(/[^a-z0-9]/g, '-') + '-' + uuidv4().slice(0, 8);\n    \n    return {\n      id,\n      label: label.startsWith('#') || label.startsWith('@') ? label : `#${label}`,\n      parentId,\n      attributes,\n      children: []\n    };\n  }\n\n  /**\n   * Add a node to the ontology tree\n   */\n  static addNode(\n    ontology: OntologyTree, \n    node: OntologyNode\n  ): OntologyTree {\n    const updatedNodes = { ...ontology.nodes, [node.id]: node };\n    let updatedRootIds = [...ontology.rootIds];\n\n    // If node has a parent, add it to parent's children\n    if (node.parentId && updatedNodes[node.parentId]) {\n      const parent = updatedNodes[node.parentId];\n      updatedNodes[node.parentId] = {\n        ...parent,\n        children: [...(parent.children || []), node.id]\n      };\n    } else {\n      // Add to root level\n      updatedRootIds.push(node.id);\n    }\n\n    return {\n      nodes: updatedNodes,\n      rootIds: updatedRootIds\n    };\n  }\n\n  /**\n   * Remove a node from the ontology tree\n   */\n  static removeNode(\n    ontology: OntologyTree, \n    nodeId: string\n  ): OntologyTree {\n    const node = ontology.nodes[nodeId];\n    if (!node) return ontology;\n\n    const updatedNodes = { ...ontology.nodes };\n    delete updatedNodes[nodeId];\n\n    // Remove from parent's children\n    if (node.parentId && updatedNodes[node.parentId]) {\n      const parent = updatedNodes[node.parentId];\n      updatedNodes[node.parentId] = {\n        ...parent,\n        children: (parent.children || []).filter(id => id !== nodeId)\n      };\n    }\n\n    // Remove from root IDs\n    let updatedRootIds = ontology.rootIds.filter(id => id !== nodeId);\n\n    // Move children to parent or root\n    const children = this.getChildNodes(ontology, nodeId);\n    children.forEach(child => {\n      updatedNodes[child.id] = {\n        ...child,\n        parentId: node.parentId\n      };\n      \n      if (!node.parentId) {\n        updatedRootIds.push(child.id);\n      } else if (updatedNodes[node.parentId]) {\n        const parent = updatedNodes[node.parentId];\n        updatedNodes[node.parentId] = {\n          ...parent,\n          children: [...(parent.children || []), child.id]\n        };\n      }\n    });\n\n    return {\n      nodes: updatedNodes,\n      rootIds: updatedRootIds\n    };\n  }\n\n  /**\n   * Update a node in the ontology tree\n   */\n  static updateNode(\n    ontology: OntologyTree, \n    nodeId: string, \n    updates: Partial<OntologyNode>\n  ): OntologyTree {\n    const node = ontology.nodes[nodeId];\n    if (!node) return ontology;\n\n    const updatedNodes = {\n      ...ontology.nodes,\n      [nodeId]: { ...node, ...updates }\n    };\n\n    return {\n      ...ontology,\n      nodes: updatedNodes\n    };\n  }\n\n  /**\n   * Move a node to a new parent\n   */\n  static moveNode(\n    ontology: OntologyTree, \n    nodeId: string, \n    newParentId?: string,\n    position?: number\n  ): OntologyTree {\n    const node = ontology.nodes[nodeId];\n    if (!node) return ontology;\n\n    const updatedNodes = { ...ontology.nodes };\n    let updatedRootIds = [...ontology.rootIds];\n\n    // Remove from old parent\n    if (node.parentId && updatedNodes[node.parentId]) {\n      const oldParent = updatedNodes[node.parentId];\n      updatedNodes[node.parentId] = {\n        ...oldParent,\n        children: (oldParent.children || []).filter(id => id !== nodeId)\n      };\n    } else {\n      // Remove from root\n      updatedRootIds = updatedRootIds.filter(id => id !== nodeId);\n    }\n\n    // Add to new parent\n    updatedNodes[nodeId] = { ...node, parentId: newParentId };\n    \n    if (newParentId && updatedNodes[newParentId]) {\n      const newParent = updatedNodes[newParentId];\n      const children = [...(newParent.children || [])];\n      \n      if (position !== undefined && position >= 0 && position <= children.length) {\n        children.splice(position, 0, nodeId);\n      } else {\n        children.push(nodeId);\n      }\n      \n      updatedNodes[newParentId] = {\n        ...newParent,\n        children\n      };\n    } else {\n      // Add to root\n      if (position !== undefined && position >= 0 && position <= updatedRootIds.length) {\n        updatedRootIds.splice(position, 0, nodeId);\n      } else {\n        updatedRootIds.push(nodeId);\n      }\n    }\n\n    return {\n      nodes: updatedNodes,\n      rootIds: updatedRootIds\n    };\n  }\n\n  /**\n   * Get child nodes of a parent\n   */\n  static getChildNodes(\n    ontology: OntologyTree, \n    parentId?: string\n  ): OntologyNode[] {\n    if (parentId) {\n      const parent = ontology.nodes[parentId];\n      if (!parent || !parent.children) return [];\n      \n      return parent.children\n        .map(childId => ontology.nodes[childId])\n        .filter(Boolean);\n    }\n    \n    // Return root nodes\n    return ontology.rootIds\n      .map(rootId => ontology.nodes[rootId])\n      .filter(Boolean);\n  }\n\n  /**\n   * Get all descendants of a node\n   */\n  static getDescendants(\n    ontology: OntologyTree, \n    nodeId: string\n  ): OntologyNode[] {\n    const descendants: OntologyNode[] = [];\n    const children = this.getChildNodes(ontology, nodeId);\n    \n    for (const child of children) {\n      descendants.push(child);\n      descendants.push(...this.getDescendants(ontology, child.id));\n    }\n    \n    return descendants;\n  }\n\n  /**\n   * Get all ancestors of a node\n   */\n  static getAncestors(\n    ontology: OntologyTree, \n    nodeId: string\n  ): OntologyNode[] {\n    const ancestors: OntologyNode[] = [];\n    const node = ontology.nodes[nodeId];\n    \n    if (node && node.parentId) {\n      const parent = ontology.nodes[node.parentId];\n      if (parent) {\n        ancestors.push(parent);\n        ancestors.push(...this.getAncestors(ontology, parent.id));\n      }\n    }\n    \n    return ancestors;\n  }\n\n  /**\n   * Find nodes by label pattern\n   */\n  static findNodes(\n    ontology: OntologyTree, \n    pattern: string\n  ): OntologyNode[] {\n    const lowercasePattern = pattern.toLowerCase();\n    \n    return Object.values(ontology.nodes).filter(node => \n      node.label.toLowerCase().includes(lowercasePattern)\n    );\n  }\n\n  /**\n   * Get semantic matches for a tag (including hierarchical relationships)\n   */\n  static getSemanticMatches(\n    ontology: OntologyTree, \n    tag: string\n  ): string[] {\n    const matches = new Set<string>([tag]);\n    \n    // Find the node for this tag\n    const node = Object.values(ontology.nodes).find(n => n.label === tag);\n    if (!node) return [tag];\n    \n    // Add ancestors (parent concepts)\n    const ancestors = this.getAncestors(ontology, node.id);\n    ancestors.forEach(ancestor => matches.add(ancestor.label));\n    \n    // Add descendants (child concepts)\n    const descendants = this.getDescendants(ontology, node.id);\n    descendants.forEach(descendant => matches.add(descendant.label));\n    \n    return Array.from(matches);\n  }\n\n  /**\n   * Validate ontology structure\n   */\n  static validate(ontology: OntologyTree): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n    \n    // Check for circular references\n    for (const nodeId of Object.keys(ontology.nodes)) {\n      if (this.hasCircularReference(ontology, nodeId)) {\n        errors.push(`Circular reference detected for node: ${nodeId}`);\n      }\n    }\n    \n    // Check for orphaned nodes\n    for (const node of Object.values(ontology.nodes)) {\n      if (node.parentId && !ontology.nodes[node.parentId]) {\n        errors.push(`Orphaned node: ${node.id} references non-existent parent: ${node.parentId}`);\n      }\n    }\n    \n    // Check root IDs exist\n    for (const rootId of ontology.rootIds) {\n      if (!ontology.nodes[rootId]) {\n        errors.push(`Root ID references non-existent node: ${rootId}`);\n      }\n    }\n    \n    return {\n      valid: errors.length === 0,\n      errors\n    };\n  }\n\n  /**\n   * Check for circular reference starting from a node\n   */\n  private static hasCircularReference(\n    ontology: OntologyTree, \n    nodeId: string, \n    visited: Set<string> = new Set()\n  ): boolean {\n    if (visited.has(nodeId)) return true;\n    \n    visited.add(nodeId);\n    const node = ontology.nodes[nodeId];\n    \n    if (node && node.parentId) {\n      return this.hasCircularReference(ontology, node.parentId, visited);\n    }\n    \n    return false;\n  }\n\n  /**\n   * Export ontology to JSON\n   */\n  static exportToJSON(ontology: OntologyTree): string {\n    return JSON.stringify(ontology, null, 2);\n  }\n\n  /**\n   * Import ontology from JSON\n   */\n  static importFromJSON(json: string): OntologyTree {\n    try {\n      const parsed = JSON.parse(json);\n      \n      // Validate structure\n      if (!parsed.nodes || !parsed.rootIds) {\n        throw new Error('Invalid ontology structure');\n      }\n      \n      return parsed as OntologyTree;\n    } catch (error) {\n      throw new Error(`Failed to parse ontology JSON: ${error}`);\n    }\n  }\n}